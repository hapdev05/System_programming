#include "../common/protocol.h"
#include <signal.h>

typedef struct {
    int socket_fd;
    char username[MAX_USERNAME_LEN];
    int current_room_id;
    room_crypto_t current_room_crypto;  // Key v√† IV c·ªßa room hi·ªán t·∫°i
    int has_room_key;  // Flag ƒë√°nh d·∫•u ƒë√£ c√≥ key ch∆∞a
    pthread_t receive_thread;
    pthread_t input_thread;
    pthread_mutex_t socket_mutex;
    int running;
} client_data_t;

client_data_t g_client;

void* receive_messages(void* arg) {
    (void)arg;
    message_t msg;
    
    while (g_client.running) {
        if (receive_message(g_client.socket_fd, &msg) < 0) {
            if (g_client.running) {
                printf("\nK·∫øt n·ªëi ƒë·∫øn server b·ªã ng·∫Øt!\n");
            }
            break;
        }
        
        // X·ª≠ l√Ω c√°c lo·∫°i message
        if (msg.type == MSG_ROOM_JOINED) {
            g_client.current_room_id = msg.room_id;
        } else if (msg.type == MSG_ROOM_LEFT) {
            g_client.current_room_id = -1;
            g_client.has_room_key = 0;
        } else if (msg.type == MSG_ROOM_KEY) {
            // Nh·∫≠n key m√£ h√≥a t·ª´ server
            hex_to_key(msg.room_key_hex, g_client.current_room_crypto.key, AES_KEY_SIZE);
            hex_to_key(msg.room_iv_hex, g_client.current_room_crypto.iv, AES_IV_SIZE);
            g_client.has_room_key = 1;
            printf("üîë ƒê√£ nh·∫≠n key m√£ h√≥a cho ph√≤ng %d\n", msg.room_id);
        } else if (msg.type == MSG_BROADCAST && msg.is_encrypted) {
            // Gi·∫£i m√£ message
            if (g_client.has_room_key) {
                if (decrypt_message_content(&msg, &g_client.current_room_crypto) == 0) {
                    print_message(&msg);
                } else {
                    printf("‚ùå Kh√¥ng th·ªÉ gi·∫£i m√£ tin nh·∫Øn\n");
                }
            }
            continue;  // Kh√¥ng in message ƒë√£ gi·∫£i m√£ hai l·∫ßn
        }
        
        print_message(&msg);
    }
    
    return NULL;
}

void* handle_input(void* arg) {
    (void)arg;
    char input[BUFFER_SIZE];
    char command[50];
    char content[MAX_MESSAGE_LEN];
    
    printf("\n=== ENCRYPTED CHAT CLIENT ===\n");
    printf("üîê Chat v·ªõi m√£ h√≥a AES-256 end-to-end\n\n");
    printf("C√°c l·ªánh c√≥ s·∫µn:\n");
    printf("  /join <username>     - ƒêƒÉng nh·∫≠p v·ªõi username\n");
    printf("  /create <room_name>  - T·∫°o ph√≤ng m·ªõi (m√£ h√≥a)\n");
    printf("  /room <room_id>      - Tham gia ph√≤ng theo ID\n");
    printf("  /leave               - R·ªùi kh·ªèi ph√≤ng hi·ªán t·∫°i\n");
    printf("  /list                - Li·ªát k√™ t·∫•t c·∫£ ph√≤ng\n");
    printf("  /quit                - Tho√°t ch∆∞∆°ng tr√¨nh\n");
    printf("  <message>            - G·ª≠i tin nh·∫Øn m√£ h√≥a\n\n");
    
    while (g_client.running) {
        printf("> ");
        fflush(stdout);
        
        if (fgets(input, sizeof(input), stdin) == NULL) {
            break;
        }
        
        input[strcspn(input, "\n")] = 0;
        
        if (strlen(input) == 0) {
            continue;
        }
        
        if (input[0] == '/') {
            sscanf(input, "%s %[^\n]", command, content);
            
            message_t msg;
            memset(&msg, 0, sizeof(message_t));
            
            pthread_mutex_lock(&g_client.socket_mutex);
            
            if (strcmp(command, "/join") == 0) {
                if (strlen(content) == 0) {
                    printf("Vui l√≤ng nh·∫≠p username!\n");
                    pthread_mutex_unlock(&g_client.socket_mutex);
                    continue;
                }
                
                msg.type = MSG_JOIN;
                strncpy(msg.username, content, MAX_USERNAME_LEN - 1);
                msg.username[MAX_USERNAME_LEN - 1] = '\0';
                strcpy(g_client.username, msg.username);
                
            } else if (strcmp(command, "/create") == 0) {
                if (strlen(content) == 0) {
                    printf("Vui l√≤ng nh·∫≠p t√™n ph√≤ng!\n");
                    pthread_mutex_unlock(&g_client.socket_mutex);
                    continue;
                }
                
                msg.type = MSG_CREATE_ROOM;
                strncpy(msg.content, content, MAX_MESSAGE_LEN - 1);
                msg.content[MAX_MESSAGE_LEN - 1] = '\0';
                
            } else if (strcmp(command, "/room") == 0) {
                int room_id = atoi(content);
                if (room_id <= 0) {
                    printf("Vui l√≤ng nh·∫≠p ID ph√≤ng h·ª£p l·ªá!\n");
                    pthread_mutex_unlock(&g_client.socket_mutex);
                    continue;
                }
                
                msg.type = MSG_JOIN_ROOM;
                msg.room_id = room_id;
                
            } else if (strcmp(command, "/leave") == 0) {
                msg.type = MSG_LEAVE_ROOM;
                
            } else if (strcmp(command, "/list") == 0) {
                msg.type = MSG_LIST_ROOMS;
                
            } else if (strcmp(command, "/quit") == 0) {
                msg.type = MSG_QUIT;
                g_client.running = 0;
                
            } else {
                printf("L·ªánh kh√¥ng h·ª£p l·ªá: %s\n", command);
                pthread_mutex_unlock(&g_client.socket_mutex);
                continue;
            }
            
            if (send_message(g_client.socket_fd, &msg) < 0) {
                printf("L·ªói g·ª≠i tin nh·∫Øn!\n");
            }
            
            pthread_mutex_unlock(&g_client.socket_mutex);
            
            if (strcmp(command, "/quit") == 0) {
                break;
            }
            
        } else {
            // Regular message - c·∫ßn m√£ h√≥a
            if (g_client.current_room_id == -1) {
                printf("B·∫°n c·∫ßn tham gia m·ªôt ph√≤ng tr∆∞·ªõc khi g·ª≠i tin nh·∫Øn!\n");
                continue;
            }
            
            if (!g_client.has_room_key) {
                printf("Ch∆∞a nh·∫≠n ƒë∆∞·ª£c key m√£ h√≥a c·ªßa ph√≤ng!\n");
                continue;
            }
            
            message_t msg;
            memset(&msg, 0, sizeof(message_t));
            msg.type = MSG_MESSAGE;
            strncpy(msg.content, input, MAX_MESSAGE_LEN - 1);
            msg.content[MAX_MESSAGE_LEN - 1] = '\0';
            
            // M√£ h√≥a message
            if (encrypt_message_content(&msg, &g_client.current_room_crypto) == 0) {
                pthread_mutex_lock(&g_client.socket_mutex);
                if (send_message(g_client.socket_fd, &msg) < 0) {
                    printf("L·ªói g·ª≠i tin nh·∫Øn!\n");
                pthread_mutex_unlock(&g_client.socket_mutex);
            } else {
                printf("‚ùå L·ªói m√£ h√≥a tin nh·∫Øn!\n");
            }
        }
    }
    
    return NULL;
}

void cleanup_client_data() {
    g_client.running = 0;
    
    if (g_client.socket_fd != -1) {
        close(g_client.socket_fd);
    }
    
    pthread_mutex_destroy(&g_client.socket_mutex);
}

void signal_handler(int sig) {
    (void)sig;
    printf("\nƒêang tho√°t...\n");
    cleanup_client_data();
    exit(0);
}

int main(int argc, char* argv[]) {
    const char* server_ip = "127.0.0.1";
    int server_port = SERVER_PORT;
    
    if (argc >= 2) {
        server_ip = argv[1];
    }
    if (argc >= 3) {
        server_port = atoi(argv[2]);
    }
    
    // Kh·ªüi t·∫°o crypto library
    init_crypto();
    
    // Kh·ªüi t·∫°o client
    g_client.socket_fd = -1;
    g_client.current_room_id = -1;
    g_client.has_room_key = 0;
    g_client.running = 1;
    pthread_mutex_init(&g_client.socket_mutex, NULL);
    
    // Setup signal handler
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    // K·∫øt n·ªëi ƒë·∫øn server
    g_client.socket_fd = create_socket();
    
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(server_port);
    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {
        error_exit("Invalid server address");
    }
    
    if (connect(g_client.socket_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        error_exit("Connection failed");
    }
    
    printf("ƒê√£ k·∫øt n·ªëi ƒë·∫øn server %s:%d\n", server_ip, server_port);
    
    // T·∫°o threads
    if (pthread_create(&g_client.receive_thread, NULL, receive_messages, NULL) != 0) {
        error_exit("Failed to create receive thread");
    }
    
    if (pthread_create(&g_client.input_thread, NULL, handle_input, NULL) != 0) {
        error_exit("Failed to create input thread");
    }
    
    // ƒê·ª£i threads k·∫øt th√∫c
    pthread_join(g_client.receive_thread, NULL);
    pthread_join(g_client.input_thread, NULL);
    
    cleanup_client_data();
    cleanup_crypto();
    
    return 0;
}
